\hypertarget{my__vector_8h_source}{}\doxysection{my\+\_\+vector.\+h}
\label{my__vector_8h_source}\index{C:/Users/1/Desktop/3sem/3sem/prog4/my\_vector.h@{C:/Users/1/Desktop/3sem/3sem/prog4/my\_vector.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#ifndef MY\_VECTOR}}
\DoxyCodeLine{2 \textcolor{preprocessor}{\#define MY\_VECTOR}}
\DoxyCodeLine{3 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{4 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{5 \textcolor{keyword}{template} <\textcolor{keyword}{class} T>}
\DoxyCodeLine{6 \textcolor{keyword}{class }\mbox{\hyperlink{class_iterator}{Iterator}};}
\DoxyCodeLine{7 \textcolor{keyword}{template} <\textcolor{keyword}{class} T>}
\DoxyCodeLine{8 \textcolor{keyword}{class }\mbox{\hyperlink{class_const___iterator}{Const\_Iterator}};}
\DoxyCodeLine{9 \textcolor{keyword}{template} <\textcolor{keyword}{class} T>}
\DoxyCodeLine{10 \textcolor{keyword}{class }\mbox{\hyperlink{classvector}{vector}} \{}
\DoxyCodeLine{11     \textcolor{keyword}{private}:}
\DoxyCodeLine{12     \textcolor{keywordtype}{int} n;}
\DoxyCodeLine{13     \textcolor{keywordtype}{int} SIZE;}
\DoxyCodeLine{14     T *arr;}
\DoxyCodeLine{15 }
\DoxyCodeLine{16     \textcolor{keyword}{public}:}
\DoxyCodeLine{17     \mbox{\hyperlink{classvector}{vector}}(): n(0), SIZE(0), arr(\textcolor{keyword}{nullptr}) \{\}}
\DoxyCodeLine{18     \mbox{\hyperlink{classvector}{\string~vector}}() \{}
\DoxyCodeLine{19         \textcolor{keyword}{delete} [] arr;}
\DoxyCodeLine{20         arr = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{21         n = 0;}
\DoxyCodeLine{22         SIZE = 0;}
\DoxyCodeLine{23     \}}
\DoxyCodeLine{24     \mbox{\hyperlink{classvector}{vector}}(\textcolor{keyword}{const} \mbox{\hyperlink{classvector}{vector<T>}}\& vec): n(vec.n), SIZE(vec.SIZE), arr(\textcolor{keyword}{new} T[vec.n]) \{}
\DoxyCodeLine{25         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < n; i++) \{}
\DoxyCodeLine{26             arr[i] = vec.arr[i];}
\DoxyCodeLine{27         \}}
\DoxyCodeLine{28     \}}
\DoxyCodeLine{29     \mbox{\hyperlink{classvector}{vector}}(\mbox{\hyperlink{classvector}{vector<T>}} \&\&vec): n(vec.n), SIZE(vec.SIZE), arr(vec.arr) \{}
\DoxyCodeLine{30         vec.arr = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{31     \}}
\DoxyCodeLine{32     \mbox{\hyperlink{classvector}{vector<T>}}\& operator =(\textcolor{keyword}{const} \mbox{\hyperlink{classvector}{vector<T>}} \&vec);}
\DoxyCodeLine{33     \mbox{\hyperlink{classvector}{vector<T>}}\& operator =(\mbox{\hyperlink{classvector}{vector<T>}} \&\&vec) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{34     \textcolor{keywordtype}{void} push\_back(\textcolor{keyword}{const} T\& value);}
\DoxyCodeLine{35 }
\DoxyCodeLine{36     \textcolor{keywordtype}{int} size() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{\textcolor{keywordflow}{return} n;\}}
\DoxyCodeLine{37     \textcolor{keywordtype}{void} clear() \textcolor{keyword}{noexcept} \{\textcolor{keyword}{delete} [] arr; arr = \textcolor{keyword}{nullptr}; n = 0; SIZE = 0;\}}
\DoxyCodeLine{38     T\& get\_elem(\textcolor{keyword}{const} \textcolor{keywordtype}{int}\& ind) \{}
\DoxyCodeLine{39         \textcolor{keywordflow}{if} (ind < 0 || ind >= n) \textcolor{keywordflow}{throw} std::logic\_error(\textcolor{stringliteral}{"{}Invalid index"{}});}
\DoxyCodeLine{40         \textcolor{keywordflow}{return} arr[ind];}
\DoxyCodeLine{41     \}}
\DoxyCodeLine{42     \textcolor{keyword}{typedef} \mbox{\hyperlink{class_iterator}{Iterator<T>}} \mbox{\hyperlink{class_iterator}{It}};}
\DoxyCodeLine{43     \textcolor{keyword}{typedef} \mbox{\hyperlink{class_const___iterator}{Const\_Iterator<T>}} \mbox{\hyperlink{class_const___iterator}{Const\_It}};}
\DoxyCodeLine{44 }
\DoxyCodeLine{45     \mbox{\hyperlink{class_iterator}{It}} begin() \{}
\DoxyCodeLine{46         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_iterator}{It}}(arr);}
\DoxyCodeLine{47     \}}
\DoxyCodeLine{48     \mbox{\hyperlink{class_iterator}{It}} end() \{}
\DoxyCodeLine{49         \textcolor{keywordflow}{if} (!arr) \{}
\DoxyCodeLine{50             \textcolor{keywordflow}{return} \mbox{\hyperlink{class_iterator}{It}}(arr);}
\DoxyCodeLine{51         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} \mbox{\hyperlink{class_iterator}{It}}(arr+n);}
\DoxyCodeLine{52     \}}
\DoxyCodeLine{53     \mbox{\hyperlink{class_const___iterator}{Const\_It}} begin()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{54         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_const___iterator}{Const\_It}}(arr);}
\DoxyCodeLine{55     \}}
\DoxyCodeLine{56     \mbox{\hyperlink{class_const___iterator}{Const\_It}} end()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{57         \textcolor{keywordflow}{if} (!arr) \{}
\DoxyCodeLine{58             \textcolor{keywordflow}{return} \mbox{\hyperlink{class_const___iterator}{Const\_It}}(arr);}
\DoxyCodeLine{59         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} \mbox{\hyperlink{class_const___iterator}{Const\_It}}(arr+n);}
\DoxyCodeLine{60     \}}
\DoxyCodeLine{61     \mbox{\hyperlink{class_iterator}{It}} erase(\mbox{\hyperlink{class_iterator}{It}} \&it);}
\DoxyCodeLine{62 \};}
\DoxyCodeLine{63 }
\DoxyCodeLine{64 \textcolor{keyword}{template} <\textcolor{keyword}{class} T>}
\DoxyCodeLine{65 \mbox{\hyperlink{class_iterator}{Iterator<T>}} \mbox{\hyperlink{classvector}{vector<T>::erase}}(\mbox{\hyperlink{class_iterator}{Iterator<T>}} \&it) \{}
\DoxyCodeLine{66     \textcolor{keywordflow}{if} (!(it -\/ begin() >= 0 \&\& end() -\/ it > 0)) \textcolor{keywordflow}{throw} std::logic\_error(\textcolor{stringliteral}{"{}Invalid iterator position"{}});}
\DoxyCodeLine{67     \mbox{\hyperlink{class_iterator}{Iterator<T>}} it1;}
\DoxyCodeLine{68     \textcolor{keywordtype}{int} k;}
\DoxyCodeLine{69     \textcolor{keywordflow}{for} (it1 = it; end() -\/ it1 > 1; it1++) \{}
\DoxyCodeLine{70         k = it1-\/begin();}
\DoxyCodeLine{71         arr[k] = arr[k+1];}
\DoxyCodeLine{72     \}}
\DoxyCodeLine{73     n-\/-\/;}
\DoxyCodeLine{74     \textcolor{keywordflow}{if} (SIZE -\/ n >= 10) \{}
\DoxyCodeLine{75         SIZE = n;}
\DoxyCodeLine{76         T *buf = \textcolor{keyword}{new} T[SIZE];}
\DoxyCodeLine{77         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < n; i++) \{}
\DoxyCodeLine{78             buf[i] = arr[i];}
\DoxyCodeLine{79         \}}
\DoxyCodeLine{80         \textcolor{keyword}{delete} [] arr;}
\DoxyCodeLine{81         arr = buf;}
\DoxyCodeLine{82     \}}
\DoxyCodeLine{83     \textcolor{keywordflow}{return} begin();}
\DoxyCodeLine{84 \}}
\DoxyCodeLine{85 }
\DoxyCodeLine{86 }
\DoxyCodeLine{87 \textcolor{keyword}{template} <\textcolor{keyword}{class} T>}
\DoxyCodeLine{88 \mbox{\hyperlink{classvector}{vector<T>}}\& \mbox{\hyperlink{classvector}{vector<T>::operator =}}(\textcolor{keyword}{const} \mbox{\hyperlink{classvector}{vector<T>}} \&vec) \{}
\DoxyCodeLine{89     \textcolor{keywordflow}{if}(\textcolor{keyword}{this} != \&vec)\{}
\DoxyCodeLine{90         \textcolor{keyword}{delete} [] arr;}
\DoxyCodeLine{91         n = vec.n;}
\DoxyCodeLine{92         SIZE = vec.size;}
\DoxyCodeLine{93         \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{94             arr = \textcolor{keyword}{new} T[SIZE];}
\DoxyCodeLine{95         \} \textcolor{keywordflow}{catch} (std::bad\_alloc \&ba) \{}
\DoxyCodeLine{96             \textcolor{keywordflow}{throw} ba;}
\DoxyCodeLine{97         \}}
\DoxyCodeLine{98         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < n; ++i)}
\DoxyCodeLine{99             arr[i] = vec.arr[i];}
\DoxyCodeLine{100     \}}
\DoxyCodeLine{101     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{102 \}}
\DoxyCodeLine{103 }
\DoxyCodeLine{104 }
\DoxyCodeLine{105 \textcolor{keyword}{template} <\textcolor{keyword}{class} T>}
\DoxyCodeLine{106 \mbox{\hyperlink{classvector}{vector<T>}} \&\mbox{\hyperlink{classvector}{vector<T>::operator=}}(\mbox{\hyperlink{classvector}{vector<T>}} \&\&vec) \textcolor{keyword}{noexcept}\{}
\DoxyCodeLine{107     \textcolor{keywordflow}{if} (\textcolor{keyword}{this} != \&vec) \{}
\DoxyCodeLine{108         \textcolor{keyword}{delete}[] arr;}
\DoxyCodeLine{109         n = vec.n;}
\DoxyCodeLine{110         SIZE = vec.SIZE;}
\DoxyCodeLine{111         arr = vec.arr;}
\DoxyCodeLine{112         vec.arr = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{113     \}}
\DoxyCodeLine{114     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{115 \}}
\DoxyCodeLine{116 }
\DoxyCodeLine{117 }
\DoxyCodeLine{118 \textcolor{keyword}{template} <\textcolor{keyword}{class} T>}
\DoxyCodeLine{119 \textcolor{keywordtype}{void} \mbox{\hyperlink{classvector}{vector<T>::push\_back}}(\textcolor{keyword}{const} T \&value) \{}
\DoxyCodeLine{120     \textcolor{keywordflow}{if} (n >= SIZE) \{}
\DoxyCodeLine{121         T *buf = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{122         \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{123             buf = \textcolor{keyword}{new} T[SIZE += 10];}
\DoxyCodeLine{124         \} \textcolor{keywordflow}{catch} (std::bad\_alloc \&ba) \{}
\DoxyCodeLine{125             \textcolor{keywordflow}{throw} ba;}
\DoxyCodeLine{126         \}}
\DoxyCodeLine{127         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < n; i++) \{}
\DoxyCodeLine{128             buf[i] = arr[i];}
\DoxyCodeLine{129         \}}
\DoxyCodeLine{130         \textcolor{keyword}{delete}[] arr;}
\DoxyCodeLine{131         arr = buf;}
\DoxyCodeLine{132     \}}
\DoxyCodeLine{133     arr[n++] = value;}
\DoxyCodeLine{134 \}}
\DoxyCodeLine{135 }
\DoxyCodeLine{136 }
\DoxyCodeLine{137 }
\DoxyCodeLine{138 \textcolor{keyword}{template} <\textcolor{keyword}{class} T>}
\DoxyCodeLine{139 \textcolor{keyword}{class }\mbox{\hyperlink{class_iterator}{Iterator}} \{}
\DoxyCodeLine{140     \textcolor{keyword}{typedef} \mbox{\hyperlink{class_iterator}{Iterator<T>}} \mbox{\hyperlink{class_iterator}{It}};}
\DoxyCodeLine{141     \textcolor{keyword}{friend} \mbox{\hyperlink{class_const___iterator}{Const\_Iterator<T>}};}
\DoxyCodeLine{142     \textcolor{keyword}{private}:}
\DoxyCodeLine{143     T *ptr;}
\DoxyCodeLine{144     \textcolor{keyword}{public}:}
\DoxyCodeLine{145     \mbox{\hyperlink{class_iterator}{Iterator}}(T *p = \textcolor{keyword}{nullptr}): ptr(p) \{\}}
\DoxyCodeLine{146     \mbox{\hyperlink{class_iterator}{Iterator}}(\textcolor{keyword}{const} \mbox{\hyperlink{class_iterator}{It}}\& it): ptr(it.ptr) \{\}}
\DoxyCodeLine{147     \textcolor{keywordtype}{bool} operator ==(\textcolor{keyword}{const} \mbox{\hyperlink{class_iterator}{It}} \&it)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{148         \textcolor{keywordflow}{return} ptr == it.ptr;}
\DoxyCodeLine{149     \}}
\DoxyCodeLine{150     \textcolor{keywordtype}{bool} operator !=(\textcolor{keyword}{const} \mbox{\hyperlink{class_iterator}{It}} \&it)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{151         \textcolor{keywordflow}{return} ptr != it.ptr;}
\DoxyCodeLine{152     \}}
\DoxyCodeLine{153     T\& operator *() \{}
\DoxyCodeLine{154         \textcolor{keywordflow}{if} (!ptr) \textcolor{keywordflow}{throw} std::logic\_error(\textcolor{stringliteral}{"{}Pointer is nullptr"{}});}
\DoxyCodeLine{155         \textcolor{keywordflow}{return} *ptr;}
\DoxyCodeLine{156     \}}
\DoxyCodeLine{157     T* operator -\/>() \{}
\DoxyCodeLine{158         \textcolor{keywordflow}{if} (!ptr) \textcolor{keywordflow}{throw} std::logic\_error(\textcolor{stringliteral}{"{}Pointer is nullptr"{}});}
\DoxyCodeLine{159         \textcolor{keywordflow}{return} ptr;}
\DoxyCodeLine{160     \}}
\DoxyCodeLine{161     \mbox{\hyperlink{class_iterator}{It}}\& operator++() \{}
\DoxyCodeLine{162         \textcolor{keywordflow}{if} (!ptr) \textcolor{keywordflow}{throw} std::logic\_error(\textcolor{stringliteral}{"{}Pointer is nullptr"{}});}
\DoxyCodeLine{163         ptr++;}
\DoxyCodeLine{164         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{165     \}}
\DoxyCodeLine{166     \mbox{\hyperlink{class_iterator}{It}} operator ++(\textcolor{keywordtype}{int}) \{}
\DoxyCodeLine{167         \textcolor{keywordflow}{if} (!ptr) \textcolor{keywordflow}{throw} std::logic\_error(\textcolor{stringliteral}{"{}Pointer is nullptr"{}});}
\DoxyCodeLine{168         \mbox{\hyperlink{class_iterator}{It}} buf(*\textcolor{keyword}{this});}
\DoxyCodeLine{169         ++*\textcolor{keyword}{this};}
\DoxyCodeLine{170         \textcolor{keywordflow}{return} buf;}
\DoxyCodeLine{171     \}}
\DoxyCodeLine{172     \textcolor{keywordtype}{int} \textcolor{keyword}{friend} operator-\/(\textcolor{keyword}{const} \mbox{\hyperlink{class_iterator}{It}}\& it1, \textcolor{keyword}{const} \mbox{\hyperlink{class_iterator}{It}} \&it2) \{}
\DoxyCodeLine{173         \textcolor{keywordflow}{if} (!it1.ptr || !it2.ptr) \textcolor{keywordflow}{throw} std::logic\_error(\textcolor{stringliteral}{"{}Pointer is nullptr"{}});}
\DoxyCodeLine{174         \textcolor{keywordflow}{return} it1.ptr -\/ it2.ptr;}
\DoxyCodeLine{175     \}}
\DoxyCodeLine{176 \};}
\DoxyCodeLine{177 }
\DoxyCodeLine{178 }
\DoxyCodeLine{179 \textcolor{keyword}{template} <\textcolor{keyword}{class} T>}
\DoxyCodeLine{180 \textcolor{keyword}{class }\mbox{\hyperlink{class_const___iterator}{Const\_Iterator}} \{}
\DoxyCodeLine{181     \textcolor{keyword}{typedef} \mbox{\hyperlink{class_const___iterator}{Const\_Iterator<T>}} \mbox{\hyperlink{class_const___iterator}{Const\_It}};}
\DoxyCodeLine{182 \textcolor{keyword}{private}:}
\DoxyCodeLine{183     T *ptr;}
\DoxyCodeLine{184 \textcolor{keyword}{public}:}
\DoxyCodeLine{185     \mbox{\hyperlink{class_const___iterator}{Const\_Iterator}}(T *p = \textcolor{keyword}{nullptr}): ptr(p) \{\}}
\DoxyCodeLine{186     \mbox{\hyperlink{class_const___iterator}{Const\_Iterator}}(\textcolor{keyword}{const} \mbox{\hyperlink{class_const___iterator}{Const\_It}}\& it): ptr(it.ptr) \{\}}
\DoxyCodeLine{187     \mbox{\hyperlink{class_const___iterator}{Const\_Iterator}}(\textcolor{keyword}{const} \mbox{\hyperlink{class_iterator}{Iterator<T>}}\& it): ptr(it.ptr) \{\}}
\DoxyCodeLine{188     \textcolor{keywordtype}{bool} operator ==(\textcolor{keyword}{const} \mbox{\hyperlink{class_const___iterator}{Const\_It}} \&it)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{189         \textcolor{keywordflow}{return} ptr == it.ptr;}
\DoxyCodeLine{190     \}}
\DoxyCodeLine{191     \textcolor{keywordtype}{bool} operator !=(\textcolor{keyword}{const} \mbox{\hyperlink{class_const___iterator}{Const\_It}} \&it)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{192         \textcolor{keywordflow}{return} ptr != it.ptr;}
\DoxyCodeLine{193     \}}
\DoxyCodeLine{194     \textcolor{keyword}{const} T\& operator *() \{}
\DoxyCodeLine{195         \textcolor{keywordflow}{if} (!ptr) \textcolor{keywordflow}{throw} std::logic\_error(\textcolor{stringliteral}{"{}Pointer is nullptr"{}});}
\DoxyCodeLine{196         \textcolor{keywordflow}{return} *ptr;}
\DoxyCodeLine{197     \}}
\DoxyCodeLine{198     \textcolor{keyword}{const} T* operator -\/>() \{}
\DoxyCodeLine{199         \textcolor{keywordflow}{if} (!ptr) \textcolor{keywordflow}{throw} std::logic\_error(\textcolor{stringliteral}{"{}Pointer is nullptr"{}});}
\DoxyCodeLine{200         \textcolor{keywordflow}{return} ptr;}
\DoxyCodeLine{201     \}}
\DoxyCodeLine{202     \mbox{\hyperlink{class_const___iterator}{Const\_It}}\& operator++() \{}
\DoxyCodeLine{203         \textcolor{keywordflow}{if} (!ptr) \textcolor{keywordflow}{throw} std::logic\_error(\textcolor{stringliteral}{"{}Pointer is nullptr"{}});}
\DoxyCodeLine{204         ptr++;}
\DoxyCodeLine{205         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{206     \}}
\DoxyCodeLine{207     \mbox{\hyperlink{class_const___iterator}{Const\_It}} operator ++(\textcolor{keywordtype}{int}) \{}
\DoxyCodeLine{208         \textcolor{keywordflow}{if} (!ptr) \textcolor{keywordflow}{throw} std::logic\_error(\textcolor{stringliteral}{"{}Pointer is nullptr"{}});}
\DoxyCodeLine{209         \mbox{\hyperlink{class_const___iterator}{Const\_It}} buf(*\textcolor{keyword}{this});}
\DoxyCodeLine{210         ++*\textcolor{keyword}{this};}
\DoxyCodeLine{211         \textcolor{keywordflow}{return} buf;}
\DoxyCodeLine{212     \}}
\DoxyCodeLine{213     \textcolor{keywordtype}{int} \textcolor{keyword}{friend} operator-\/(\textcolor{keyword}{const} \mbox{\hyperlink{class_const___iterator}{Const\_It}}\& it1, \textcolor{keyword}{const} \mbox{\hyperlink{class_const___iterator}{Const\_It}} \&it2) \{}
\DoxyCodeLine{214         \textcolor{keywordflow}{if} (!it1.ptr || !it2.ptr) \textcolor{keywordflow}{throw} std::logic\_error(\textcolor{stringliteral}{"{}Pointer is nullptr"{}});}
\DoxyCodeLine{215         \textcolor{keywordflow}{return} it1.ptr -\/ it2.ptr;}
\DoxyCodeLine{216     \}}
\DoxyCodeLine{217 \};}
\DoxyCodeLine{218 \textcolor{preprocessor}{\#endif}}

\end{DoxyCode}
